<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libnetconf2: Client Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libnetconf2<span id="projectnumber">&#160;2.1.37</span>
   </div>
   <div id="projectbrief">NETCONF server and client library in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__client__session.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Client Session<div class="ingroups"><a class="el" href="group__client.html">Client</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Client-side NETCONF session manipulation.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Client Session:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group__client__session.svg" width="234" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga402eae95902f79a08df6254d2b350d32" id="r_ga402eae95902f79a08df6254d2b350d32"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga402eae95902f79a08df6254d2b350d32">nc_notif_dispatch_clb</a>) (struct nc_session *session, const struct lyd_node *envp, const struct lyd_node *op, void *user_data)</td></tr>
<tr class="memdesc:ga402eae95902f79a08df6254d2b350d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for receiving notifications in a separate thread.  <br /></td></tr>
<tr class="separator:ga402eae95902f79a08df6254d2b350d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga964147343483e599e380a13bb516ba92" id="r_ga964147343483e599e380a13bb516ba92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga964147343483e599e380a13bb516ba92">nc_client_session_set_not_strict</a> (struct nc_session *session)</td></tr>
<tr class="memdesc:ga964147343483e599e380a13bb516ba92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a session not strict when sending RPCs and receiving RPC replies. In other words, it will silently skip unknown nodes without an error.  <br /></td></tr>
<tr class="separator:ga964147343483e599e380a13bb516ba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c9b10d1f303aac8d5421501798107c" id="r_ga66c9b10d1f303aac8d5421501798107c"><td class="memItemLeft" align="right" valign="top">struct nc_session *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga66c9b10d1f303aac8d5421501798107c">nc_connect_inout</a> (int fdin, int fdout, struct ly_ctx *ctx)</td></tr>
<tr class="memdesc:ga66c9b10d1f303aac8d5421501798107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the NETCONF server via proviaded input/output file descriptors.  <br /></td></tr>
<tr class="separator:ga66c9b10d1f303aac8d5421501798107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45a4076d3bfea089d9e8373671a66d1" id="r_gaf45a4076d3bfea089d9e8373671a66d1"><td class="memItemLeft" align="right" valign="top">struct nc_session *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#gaf45a4076d3bfea089d9e8373671a66d1">nc_connect_unix</a> (const char *address, struct ly_ctx *ctx)</td></tr>
<tr class="memdesc:gaf45a4076d3bfea089d9e8373671a66d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the NETCONF server via unix socket.  <br /></td></tr>
<tr class="separator:gaf45a4076d3bfea089d9e8373671a66d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c554afd7a93b3eb5d69d1ab5fef4c00" id="r_ga0c554afd7a93b3eb5d69d1ab5fef4c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga0c554afd7a93b3eb5d69d1ab5fef4c00">nc_recv_notif</a> (struct nc_session *session, int timeout, struct lyd_node **envp, struct lyd_node **op)</td></tr>
<tr class="memdesc:ga0c554afd7a93b3eb5d69d1ab5fef4c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive NETCONF Notification.  <br /></td></tr>
<tr class="separator:ga0c554afd7a93b3eb5d69d1ab5fef4c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0655a8d23e0dd6745d600b45311a56de" id="r_ga0655a8d23e0dd6745d600b45311a56de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga0655a8d23e0dd6745d600b45311a56de">nc_recv_notif_dispatch</a> (struct nc_session *session, <a class="el" href="group__client__session.html#ga402eae95902f79a08df6254d2b350d32">nc_notif_dispatch_clb</a> notif_clb)</td></tr>
<tr class="memdesc:ga0655a8d23e0dd6745d600b45311a56de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationComplete&gt; is received.  <br /></td></tr>
<tr class="separator:ga0655a8d23e0dd6745d600b45311a56de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd4d65f4794714fbbc16e5a14fadda5" id="r_ga8dd4d65f4794714fbbc16e5a14fadda5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga8dd4d65f4794714fbbc16e5a14fadda5">nc_recv_notif_dispatch_data</a> (struct nc_session *session, <a class="el" href="group__client__session.html#ga402eae95902f79a08df6254d2b350d32">nc_notif_dispatch_clb</a> notif_clb, void *user_data, void(*free_data)(void *))</td></tr>
<tr class="memdesc:ga8dd4d65f4794714fbbc16e5a14fadda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationComplete&gt; is received. Similar to <a class="el" href="group__client__session.html#ga0655a8d23e0dd6745d600b45311a56de" title="Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationCo...">nc_recv_notif_dispatch()</a> but allows to set arbitrary user data that can be freed as well.  <br /></td></tr>
<tr class="separator:ga8dd4d65f4794714fbbc16e5a14fadda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfe333eeb6dea6fa85d0a9794ab7d7a" id="r_ga3cfe333eeb6dea6fa85d0a9794ab7d7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga3cfe333eeb6dea6fa85d0a9794ab7d7a">nc_recv_reply</a> (struct nc_session *session, struct <a class="el" href="group__client__msg.html#structnc__rpc">nc_rpc</a> *rpc, uint64_t msgid, int timeout, struct lyd_node **envp, struct lyd_node **op)</td></tr>
<tr class="memdesc:ga3cfe333eeb6dea6fa85d0a9794ab7d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive NETCONF RPC reply.  <br /></td></tr>
<tr class="separator:ga3cfe333eeb6dea6fa85d0a9794ab7d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac0805b9a2f6538244c52eead088612" id="r_gaeac0805b9a2f6538244c52eead088612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#gaeac0805b9a2f6538244c52eead088612">nc_send_rpc</a> (struct nc_session *session, struct <a class="el" href="group__client__msg.html#structnc__rpc">nc_rpc</a> *rpc, int timeout, uint64_t *msgid)</td></tr>
<tr class="memdesc:gaeac0805b9a2f6538244c52eead088612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send NETCONF RPC message via the session.  <br /></td></tr>
<tr class="separator:gaeac0805b9a2f6538244c52eead088612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0791be1e4e6d0628d2690884a511c1" id="r_gaad0791be1e4e6d0628d2690884a511c1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#gaad0791be1e4e6d0628d2690884a511c1">nc_session_cpblt</a> (const struct nc_session *session, const char *capab)</td></tr>
<tr class="memdesc:gaad0791be1e4e6d0628d2690884a511c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check capability presence in a session.  <br /></td></tr>
<tr class="separator:gaad0791be1e4e6d0628d2690884a511c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305395176d1c17912f6442271b5359a1" id="r_ga305395176d1c17912f6442271b5359a1"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga305395176d1c17912f6442271b5359a1">nc_session_get_cpblts</a> (const struct nc_session *session)</td></tr>
<tr class="memdesc:ga305395176d1c17912f6442271b5359a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get session capabilities.  <br /></td></tr>
<tr class="separator:ga305395176d1c17912f6442271b5359a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c8430f6e926475b3415bd6ea820030" id="r_ga12c8430f6e926475b3415bd6ea820030"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__client__session.html#ga12c8430f6e926475b3415bd6ea820030">nc_session_ntf_thread_running</a> (const struct nc_session *session)</td></tr>
<tr class="memdesc:ga12c8430f6e926475b3415bd6ea820030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the session has a notification thread running.  <br /></td></tr>
<tr class="separator:ga12c8430f6e926475b3415bd6ea820030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Client-side NETCONF session manipulation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga402eae95902f79a08df6254d2b350d32" name="ga402eae95902f79a08df6254d2b350d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga402eae95902f79a08df6254d2b350d32">&#9670;&#160;</a></span>nc_notif_dispatch_clb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nc_notif_dispatch_clb) (struct nc_session *session, const struct lyd_node *envp, const struct lyd_node *op, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for receiving notifications in a separate thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>NC session that received the notification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envp</td><td>Notification envelope data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>Notification body data tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Arbitrary user data passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="session__client_8h_source.html#l00578">578</a> of file <a class="el" href="session__client_8h_source.html">session_client.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga964147343483e599e380a13bb516ba92" name="ga964147343483e599e380a13bb516ba92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964147343483e599e380a13bb516ba92">&#9670;&#160;</a></span>nc_client_session_set_not_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nc_client_session_set_not_strict </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a session not strict when sending RPCs and receiving RPC replies. In other words, it will silently skip unknown nodes without an error. </p>
<p>Generally, no such data should be worked with, so use this function only when you know what you are doing and you understand the consequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>NETCONF client session. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66c9b10d1f303aac8d5421501798107c" name="ga66c9b10d1f303aac8d5421501798107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c9b10d1f303aac8d5421501798107c">&#9670;&#160;</a></span>nc_connect_inout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nc_session * nc_connect_inout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fdin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fdout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ly_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the NETCONF server via proviaded input/output file descriptors. </p>
<p>Transport layer is supposed to be already set. Function do not cover authentication or any other manipulation with the transport layer, it only establish NETCONF session by sending and processing NETCONF &lt;hello&gt; messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fdin</td><td>Input file descriptor for reading (clear) data from NETCONF server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdout</td><td>Output file descriptor for writing (clear) data for NETCONF server. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Optional custom context to use for the session. If not set, a default context is created. Any YANG modules not present in the context and supported by the server are loaded using &lt;get-schema&gt; (if supported) and/or by searching the searchpath (see <a class="el" href="group__client.html#ga4fb8b91a9bd992e1fe3008245302edda" title="Set location where libnetconf tries to search for YANG/YIN schemas.">nc_client_set_schema_searchpath()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created NETCONF session object or NULL in case of error. </dd></dl>

</div>
</div>
<a id="gaf45a4076d3bfea089d9e8373671a66d1" name="gaf45a4076d3bfea089d9e8373671a66d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45a4076d3bfea089d9e8373671a66d1">&#9670;&#160;</a></span>nc_connect_unix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nc_session * nc_connect_unix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ly_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the NETCONF server via unix socket. </p>
<p>Connect to netconf server via an unix socket. Function do not cover authentication or any other manipulation with the transport layer, it only establish NETCONF session by sending and processing NETCONF &lt;hello&gt; messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Path to the unix socket. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Optional custom context to use for the session. If not set, a default context is created. Any YANG modules not present in the context and supported by the server are loaded using &lt;get-schema&gt; (if supported) and/or by searching the searchpath (see <a class="el" href="group__client.html#ga4fb8b91a9bd992e1fe3008245302edda" title="Set location where libnetconf tries to search for YANG/YIN schemas.">nc_client_set_schema_searchpath()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Created NETCONF session object or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ga0c554afd7a93b3eb5d69d1ab5fef4c00" name="ga0c554afd7a93b3eb5d69d1ab5fef4c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c554afd7a93b3eb5d69d1ab5fef4c00">&#9670;&#160;</a></span>nc_recv_notif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a> nc_recv_notif </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lyd_node **&#160;</td>
          <td class="paramname"><em>envp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lyd_node **&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive NETCONF Notification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>NETCONF session from which the function gets data. It must be the client side session object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout for reading in milliseconds. Use negative value for infinite waiting and 0 for immediate return if data are not available on the wire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">envp</td><td>NETCONF notification XML envelopes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op</td><td>Parsed NETCONF notification data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057aacb43c141e7a5b0065d464679dfbd76e">NC_MSG_NOTIF</a> for success, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a5b0ce1ca54b15ef3ca1ef901263c1b72">NC_MSG_WOULDBLOCK</a> if <code>timeout</code> has elapsed, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a85873f32bc8f5b4118ee2b7d42635c07">NC_MSG_ERROR</a> if reading has failed, and <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a827b3c9c898a48ec8e9f8f9af11f1bdd">NC_MSG_REPLY</a> if a reply was read instead (call this function again to get a notification). </dd></dl>

</div>
</div>
<a id="ga0655a8d23e0dd6745d600b45311a56de" name="ga0655a8d23e0dd6745d600b45311a56de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0655a8d23e0dd6745d600b45311a56de">&#9670;&#160;</a></span>nc_recv_notif_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nc_recv_notif_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__client__session.html#ga402eae95902f79a08df6254d2b350d32">nc_notif_dispatch_clb</a>&#160;</td>
          <td class="paramname"><em>notif_clb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationComplete&gt; is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Netconf session to read notifications from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notif_clb</td><td>Function that is called for every received notification (including &lt;notificationComplete&gt;). Parameters are the session the notification was received on and the notification data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the thread was successfully created, -1 on error. </dd></dl>

</div>
</div>
<a id="ga8dd4d65f4794714fbbc16e5a14fadda5" name="ga8dd4d65f4794714fbbc16e5a14fadda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dd4d65f4794714fbbc16e5a14fadda5">&#9670;&#160;</a></span>nc_recv_notif_dispatch_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nc_recv_notif_dispatch_data </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__client__session.html#ga402eae95902f79a08df6254d2b350d32">nc_notif_dispatch_clb</a>&#160;</td>
          <td class="paramname"><em>notif_clb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationComplete&gt; is received. Similar to <a class="el" href="group__client__session.html#ga0655a8d23e0dd6745d600b45311a56de" title="Receive NETCONF Notifications in a separate thread until the session is terminated or &lt;notificationCo...">nc_recv_notif_dispatch()</a> but allows to set arbitrary user data that can be freed as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Netconf session to read notifications from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notif_clb</td><td>Callback that is called for every received notification (including &lt;notificationComplete&gt;). Parameters are the session the notification was received on and the notification data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>Arbitrary user data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_data</td><td>Callback for freeing the user data after notif thread exit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the thread was successfully created, -1 on error. </dd></dl>

</div>
</div>
<a id="ga3cfe333eeb6dea6fa85d0a9794ab7d7a" name="ga3cfe333eeb6dea6fa85d0a9794ab7d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cfe333eeb6dea6fa85d0a9794ab7d7a">&#9670;&#160;</a></span>nc_recv_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a> nc_recv_reply </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__client__msg.html#structnc__rpc">nc_rpc</a> *&#160;</td>
          <td class="paramname"><em>rpc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>msgid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lyd_node **&#160;</td>
          <td class="paramname"><em>envp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lyd_node **&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive NETCONF RPC reply. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be called in a single thread only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>NETCONF session from which the function gets data. It must be the client side session object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc</td><td>Original RPC this should be the reply to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msgid</td><td>Expected message ID of the reply. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout for reading in milliseconds. Use negative value for infinite waiting and 0 for immediate return if data are not available on the wire. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">envp</td><td>NETCONF rpc-reply XML envelopes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">op</td><td>Parsed NETCONF reply data, if any (none for &lt;ok&gt; or error replies). Set only on <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a827b3c9c898a48ec8e9f8f9af11f1bdd">NC_MSG_REPLY</a> and <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a0fb819d9672b32dd82280d2d4dcb4d22">NC_MSG_REPLY_ERR_MSGID</a> return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a827b3c9c898a48ec8e9f8f9af11f1bdd">NC_MSG_REPLY</a> for success, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a5b0ce1ca54b15ef3ca1ef901263c1b72">NC_MSG_WOULDBLOCK</a> if <code>timeout</code> has elapsed, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a85873f32bc8f5b4118ee2b7d42635c07">NC_MSG_ERROR</a> if reading has failed, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057aacb43c141e7a5b0065d464679dfbd76e">NC_MSG_NOTIF</a> if a notification was read instead (call this function again to get the reply), and <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a0fb819d9672b32dd82280d2d4dcb4d22">NC_MSG_REPLY_ERR_MSGID</a> if a reply with missing or wrong message-id was received. </dd></dl>

</div>
</div>
<a id="gaeac0805b9a2f6538244c52eead088612" name="gaeac0805b9a2f6538244c52eead088612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac0805b9a2f6538244c52eead088612">&#9670;&#160;</a></span>nc_send_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga298c7a4ad5cc76169a211f86df90f057">NC_MSG_TYPE</a> nc_send_rpc </td>
          <td>(</td>
          <td class="paramtype">struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__client__msg.html#structnc__rpc">nc_rpc</a> *&#160;</td>
          <td class="paramname"><em>rpc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>msgid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send NETCONF RPC message via the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>NETCONF session where the RPC will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rpc</td><td>NETCONF RPC object to send via the specified session. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout for writing in milliseconds. Use negative value for infinite waiting and 0 for return if data cannot be sent immediately. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">msgid</td><td>If RPC was successfully sent, this is it's message ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a7f6951d98d30342a65e6b1d7ccca2df0">NC_MSG_RPC</a> on success, <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a5b0ce1ca54b15ef3ca1ef901263c1b72">NC_MSG_WOULDBLOCK</a> in case of a busy session, and <a class="el" href="group__misc.html#gga298c7a4ad5cc76169a211f86df90f057a85873f32bc8f5b4118ee2b7d42635c07">NC_MSG_ERROR</a> on error. </dd></dl>

</div>
</div>
<a id="gaad0791be1e4e6d0628d2690884a511c1" name="gaad0791be1e4e6d0628d2690884a511c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0791be1e4e6d0628d2690884a511c1">&#9670;&#160;</a></span>nc_session_cpblt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * nc_session_cpblt </td>
          <td>(</td>
          <td class="paramtype">const struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>capab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check capability presence in a session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capab</td><td>Capability to look for, capability with any additional suffix will match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matching capability, NULL if none found. </dd></dl>

</div>
</div>
<a id="ga305395176d1c17912f6442271b5359a1" name="ga305395176d1c17912f6442271b5359a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305395176d1c17912f6442271b5359a1">&#9670;&#160;</a></span>nc_session_get_cpblts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *const  * nc_session_get_cpblts </td>
          <td>(</td>
          <td class="paramtype">const struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get session capabilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session to get the information from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL-terminated array of the <code>session</code> capabilities. </dd></dl>

</div>
</div>
<a id="ga12c8430f6e926475b3415bd6ea820030" name="ga12c8430f6e926475b3415bd6ea820030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c8430f6e926475b3415bd6ea820030">&#9670;&#160;</a></span>nc_session_ntf_thread_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nc_session_ntf_thread_running </td>
          <td>(</td>
          <td class="paramtype">const struct nc_session *&#160;</td>
          <td class="paramname"><em>session</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the session has a notification thread running. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>Session to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if notfication thread is running, 0 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 19 2025 19:27:10 for libnetconf2 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
